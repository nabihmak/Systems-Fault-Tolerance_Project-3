import grpc
from concurrent import futures
import argparse
import time
import sys
import random
import os

# Imports generated by Docker
import two_pc_pb2
import two_pc_pb2_grpc

# --- LOGGING HELPER ---
def log_event(phase, src, rpc, dest):
    # Strict format: Phase <phase_name> of Node <node_id> sends RPC <rpc_name> to Phase <phase_name> of Node <node_id>
    print(f"Phase {phase} of Node {src} sends RPC {rpc} to Phase {phase} of Node {dest}", flush=True)

class TwoPCNode(two_pc_pb2_grpc.TwoPCServiceServicer):
    def __init__(self, node_id):
        self.node_id = node_id
        self.transaction_log = {} # Simulated storage

    # --- Q1: VOTING PHASE (Participant) ---
    def RequestVote(self, request, context):
        # Simulation: 80% chance to vote Commit
        vote_decision = random.random() > 0.2
        vote_str = "VoteCommit" if vote_decision else "VoteAbort"
        
        # LOG: Sending Vote
        log_event("Voting", self.node_id, vote_str, "Coordinator")
        
        return two_pc_pb2.VoteResponse(vote=vote_decision, node_id=self.node_id)

    # --- Q2: DECISION PHASE (Participant) ---
    def GlobalCommit(self, request, context):
        # LOG: Acknowledge Commit
        # Note: The prompt asks to log the RPC *sending*. 
        # Since we are receiving, we log the ACK we are about to send back.
        log_event("Decision", self.node_id, "Ack(Committed)", "Coordinator")
        
        # Execute Commit
        self.transaction_log[request.transaction_id] = "COMMITTED"
        return two_pc_pb2.Ack(success=True, message="Committed")
        
    def GlobalAbort(self, request, context):
        # LOG: Acknowledge Abort
        log_event("Decision", self.node_id, "Ack(Aborted)", "Coordinator")
        
        # Execute Abort
        self.transaction_log[request.transaction_id] = "ABORTED"
        return two_pc_pb2.Ack(success=True, message="Aborted")

def run_server(node_id, port):
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    two_pc_pb2_grpc.add_TwoPCServiceServicer_to_server(TwoPCNode(node_id), server)
    server.add_insecure_port(f'[::]:{port}')
    server.start()
    print(f"Node {node_id} is running on port {port}...", flush=True)
    server.wait_for_termination()

def run_coordinator(participants):
    print("Coordinator: Starting Voting Phase...", flush=True)
    time.sleep(10) # Wait for network
    
    votes = []
    
    # --- STEP 1: VOTING PHASE ---
    for p_address in participants:
        target_node = p_address.split(':')[0]
        try:
            with grpc.insecure_channel(p_address) as channel:
                stub = two_pc_pb2_grpc.TwoPCServiceStub(channel)
                
                log_event("Voting", "Coordinator", "RequestVote", target_node)
                
                response = stub.RequestVote(two_pc_pb2.VoteRequest(
                    transaction_id="tx-1", coordinator_id="Coordinator"
                ))
                votes.append(response.vote)
                
        except Exception as e:
            print(f"Coordinator: Failed to reach {target_node}", flush=True)
            votes.append(False) # Fail = Abort

    # --- STEP 2: MAKE DECISION ---
    final_decision = all(votes) and len(votes) > 0
    decision_rpc = "GlobalCommit" if final_decision else "GlobalAbort"
    print(f"\nCoordinator: Votes collected. Decision is {decision_rpc.upper()}.\n", flush=True)

    # --- STEP 3: DECISION PHASE ---
    for p_address in participants:
        target_node = p_address.split(':')[0]
        try:
            with grpc.insecure_channel(p_address) as channel:
                stub = two_pc_pb2_grpc.TwoPCServiceStub(channel)
                
                # LOG: Sending Decision
                log_event("Decision", "Coordinator", decision_rpc, target_node)
                
                # Send the appropriate RPC
                req = two_pc_pb2.DecisionRequest(transaction_id="tx-1")
                if final_decision:
                    stub.GlobalCommit(req)
                else:
                    stub.GlobalAbort(req)
                    
        except Exception as e:
            print(f"Coordinator: Failed to send decision to {target_node}", flush=True)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--role', choices=['coordinator', 'participant'], required=True)
    parser.add_argument('--id', type=str, required=True)
    parser.add_argument('--participants', type=str, help="Comma-separated list of participant addresses")
    args = parser.parse_args()

    if args.role == 'participant':
        run_server(args.id, '50051')
    else:
        if args.participants:
            plist = args.participants.split(',')
            run_coordinator(plist)